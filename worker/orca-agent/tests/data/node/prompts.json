[
  {
    "prompt": "Feature Overview:\nDevelop a comprehensive bulk bookmark import system that allows users to efficiently upload and integrate bookmarks from multiple file formats (CSV, TXT, MD, HTML) into their bookmark management application. The goal is to provide a seamless, secure, and user-friendly method for importing multiple bookmarks simultaneously.\n\nAI Role and Expertise:\nYou are a senior full-stack software engineer with expertise in React, Node.js, file parsing, input validation, and secure web application development. Your task is to design and implement a robust, scalable bulk bookmark import feature that handles various file formats, ensures data integrity, and provides an excellent user experience.\n\nImplementation Context:\nThe bulk bookmark import feature encompasses multiple critical components:\n- Frontend file upload interface with drag-and-drop support\n- Parsers for multiple file formats (CSV, TXT, MD, HTML)\n- Backend API for handling file uploads and processing\n- Database insertion mechanism for imported bookmarks\n- Comprehensive input validation and error handling\n- User feedback system for import progress and results\n\nTechnical Guidelines:\n- Use React for frontend components\n- Implement backend with Node.js/Express\n- Support file types: CSV, TXT, Markdown, HTML\n- Handle various file encodings and structures\n- Ensure maximum file size limit (e.g., 10MB)\n- Support bulk import of up to 500 bookmarks per upload\n- Implement cross-platform compatibility\n- Use TypeScript for type safety\n\nCoding Standards:\n- Follow functional and modular programming principles\n- Implement comprehensive error handling\n- Write clean, self-documenting code\n- Use TypeScript for strong typing\n- Implement comprehensive logging\n- Follow React functional component and hooks patterns\n- Use async/await for asynchronous operations\n- Implement proper input sanitization\n- Write unit and integration tests for all components\n\nTask Dependencies and Relationships:\n1. File Input Component depends on:\n   - Input validation logic\n   - File type detection\n   - Error handling mechanisms\n\n2. File Parsers (CSV, HTML, Markdown) are independent but should:\n   - Share a common interface\n   - Return standardized bookmark data structure\n   - Implement consistent error handling\n\n3. Backend API depends on:\n   - File parsers\n   - Input validation system\n   - Database insertion service\n\n4. Database Insertion Service requires:\n   - Validated and parsed bookmark data\n   - Transaction management\n   - Duplicate detection mechanism\n\n5. Frontend Progress UI depends on:\n   - Backend import process\n   - Real-time import status updates\n\nSecurity Considerations:\n- Implement strict file type validation\n- Sanitize all input data\n- Prevent potential XSS and injection attacks\n- Implement server-side validation\n- Use secure file upload mechanisms\n- Limit file size and total bookmark count\n\nQuality and Testing Requirements:\n- 100% unit test coverage for parsing logic\n- Integration tests for file upload and processing\n- Performance testing for large file imports\n- Comprehensive error handling and user feedback\n- Cross-browser and responsive design testing\n- Security vulnerability scanning\n\nPerformance Optimization:\n- Implement efficient batch database insertions\n- Use streaming for large file processing\n- Minimize memory usage during parsing\n- Implement lazy loading for import results\n\nConstraints and Limitations:\n- Maximum file size: 10MB\n- Maximum bookmarks per import: 500\n- Supported file formats: CSV, TXT, MD, HTML\n- Requires user authentication\n\nUser Experience Guidelines:\n- Provide clear, actionable feedback for all operations\n- Design intuitive, accessible upload interface\n- Support drag-and-drop and file selection\n- Show detailed import progress and results\n- Offer options to retry or modify failed imports\n\nRemember: The goal is to create a robust, user-friendly bulk bookmark import system that prioritizes security, performance, and ease of use.",
    "bountyId": "test_bounty_21f6667d-443f-4290-b5c2-52cae4b16da2",
    "createdAt": {
      "$date": "2025-05-07T12:32:20.831Z"
    },
    "updatedAt": {
      "$date": "2025-05-07T12:32:20.831Z"
    }
  },
  {
    "prompt": "---\nFeature Overview:\nImplement a robust, user-friendly dark mode for the application that provides an alternative color scheme, enhances user experience, and supports accessibility. The dark mode should seamlessly integrate with the existing design system, offer user preference controls, and automatically adapt to system settings.\n\nAI Role and Expertise:\nYou are a senior frontend developer and UX architect specializing in responsive design, color theory, and accessibility. Your expertise spans UI/UX design, CSS styling, JavaScript implementation, and cross-browser compatibility.\n\nImplementation Context:\nDark mode is a critical user experience feature that:\n- Reduces eye strain in low-light environments\n- Provides user interface personalization\n- Improves accessibility and readability\n- Supports modern design trends and user preferences\n\nThe implementation requires a holistic approach covering:\n- Color palette design\n- UI component styling\n- User preference management\n- System preference detection\n- Compatibility with third-party components\n- Visual regression testing\n\nTechnical Guidelines:\n- Use CSS custom properties (variables) for color management\n- Implement responsive design principles\n- Ensure WCAG 2.1 Level AA color contrast standards\n- Support modern browsers and responsive layouts\n- Minimize performance overhead of mode switching\n- Use prefers-color-scheme media query for system detection\n- Store user preferences securely in localStorage\n\nCoding Standards:\n- Follow semantic HTML structure\n- Use BEM or similar CSS naming conventions\n- Write modular, reusable CSS classes\n- Implement progressive enhancement\n- Ensure keyboard navigation and screen reader compatibility\n- Use CSS transitions for smooth mode switching\n- Write clean, commented, and self-documenting code\n- Handle edge cases and provide fallback styles\n\nTask Dependencies and Relationships:\n1. Color Palette Design → Foundational for all subsequent styling tasks\n2. CSS Styles → Depends on color palette, influences all visual components\n3. Toggle Implementation → Requires color palette and CSS styles\n4. System Preference Detection → Builds upon toggle implementation\n5. External Component Support → Requires core dark mode infrastructure\n6. Screenshot Tests → Validates all previous implementation stages\n\nTask Execution Order:\n1. Define color palette\n2. Implement base CSS styles\n3. Create mode toggle\n4. Add system preference detection\n5. Extend to external components\n6. Implement visual regression tests\n\nQuality and Testing Requirements:\n- 100% component coverage in dark mode\n- WCAG 2.1 Level AA color contrast compliance\n- Cross-browser and cross-device compatibility\n- Performance budget: Mode switching < 50ms\n- Accessibility testing with screen readers\n- Visual regression tests for all components\n- Comprehensive user preference handling\n- Graceful degradation for unsupported browsers\n\nAdditional Constraints:\n- Minimize additional JavaScript bundle size\n- Use native browser APIs where possible\n- Provide clear user feedback during mode switching\n- Ensure accessibility for users with visual impairments\n\nDeliverable Expectations:\n- Fully responsive dark mode implementation\n- Consistent design across all application components\n- Smooth, performant mode switching\n- Clear user controls and system integration\n- Comprehensive test coverage\n---",
    "bountyId": "test_bounty_048451fd-b0b8-47f7-9648-3a04e6223840",
    "createdAt": {
      "$date": "2025-05-07T12:43:13.121Z"
    },
    "updatedAt": {
      "$date": "2025-05-07T12:43:13.122Z"
    }
  }
]
